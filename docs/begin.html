<!DOCTYPE html>

<html>
<head>
  <title>begin.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>begin.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/* 
 * begin.js
 * 
 * Copyright (c) 2013-2015, Kenneth Lo Shih
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met: 
 * 
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution. 
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(root)</span> {</span>
<span class="hljs-pi">  "use strict"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>var env = typeof(process) == ‘object’ ? process.env : root;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-comment">/*
   * begin()
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">begin</span><span class="hljs-params">(context)</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Root(<span class="hljs-literal">null</span>, context);
  }
  
  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                                Statements                                | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-keyword">var</span> ArgKind = begin.ArgKind = <span class="hljs-number">0x1</span>,
      ErrKind = begin.ErrKind = <span class="hljs-number">0x2</span>,
      BrkKind = begin.BrkKind = <span class="hljs-number">0x4</span>,
      RetKind = begin.RetKind = <span class="hljs-number">0x8</span>,
      AllKind = begin.AllKind = <span class="hljs-number">0xf</span>;
  <span class="hljs-keyword">var</span> STACK_MARKER = <span class="hljs-string">'STACK'</span>;
  <span class="hljs-keyword">var</span> slice = <span class="hljs-built_in">Array</span>.prototype.slice;

  <span class="hljs-comment">/* Find a next tick function. Try node.js's process.nextTick, setImmediate()
   * the finally setTimeout(). Use a polyfill if this isn't node and
   * setImmediate()'s not available https://github.com/YuzuJS/setImmediate */</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(root.setImmediate) == <span class="hljs-string">'function'</span>)
    begin.setImmediate = root.setImmediate;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(setImmediate) == <span class="hljs-string">'function'</span>)
    begin.setImmediate = setImmediate;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(process) != <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span>(process.nextTick) == <span class="hljs-string">'function'</span>)
    begin.setImmediate = process.nextTick;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(root.setTimeout) == <span class="hljs-string">'function'</span>)
    begin.setImmediate = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(func)</span> {</span> <span class="hljs-keyword">return</span> root.setTimeout(func, <span class="hljs-number">0</span>) };
  <span class="hljs-keyword">else</span>
    begin.setImmediate = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(func)</span> {</span> <span class="hljs-keyword">return</span> setTimeout(func, <span class="hljs-number">0</span>) };

  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                                   Call                                   | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-comment">/** The Call class provides a representation. Calls also provide a Promise/A+
   *  and Deferred interfaces for convenience. It also provides an interfae to
   *  run() as a handler (no error first arg) or callback (yes error first
   *  arg).
   *  
   *  @since  1.0
   */</span>
  <span class="hljs-keyword">var</span> Call = begin.Call = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Call</span><span class="hljs-params">(block, context)</span> {</span>
    <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'new'</span>;
    <span class="hljs-keyword">this</span>.block = block;
    <span class="hljs-keyword">this</span>.context = context || {};
    <span class="hljs-keyword">this</span>.error = <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">this</span>.params = [];
  };
  
  Call.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.constructor.name + <span class="hljs-string">"(error:"</span> + <span class="hljs-keyword">this</span>.error + <span class="hljs-string">",params:"</span> + <span class="hljs-keyword">this</span>.params.join(<span class="hljs-string">','</span>) + (<span class="hljs-keyword">this</span>.subcalls ? <span class="hljs-string">",subcalls="</span> + <span class="hljs-keyword">this</span>.subcalls.length : <span class="hljs-string">""</span>) + <span class="hljs-string">")"</span>;
  };

  <span class="hljs-comment">/** Runs the call. Set the error, params and context prior to calling run.
   *  
   *  @param  callback The callback function ({function(err,..)})
   *  @since  1.0
   */</span>
  Call.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status != <span class="hljs-string">'new'</span>)
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Call cannot be run twice"</span>);
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.block) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"No block"</span>);
      <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'done'</span>;
      <span class="hljs-keyword">return</span> callback &amp;&amp; callback(), <span class="hljs-literal">undefined</span>;
    }
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'running'</span>;
hook &amp;&amp; hook.emit(<span class="hljs-string">'onBeginCall'</span>, <span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.block.run(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      self.status = <span class="hljs-string">'done'</span>;
hook &amp;&amp; hook.emit(<span class="hljs-string">'onEndCall'</span>, self);
      callback &amp;&amp; callback();
    });
  };

  <span class="hljs-comment">/** Sets the *error* and *params*.
   *  
   *  @param  error The error (optional)
   *  @param  params The parameters ({array}, optional)
   *  @return this
   *  @since  1.0
   */</span>
  Call.prototype.set = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error, params)</span> {</span>
    <span class="hljs-keyword">if</span> (error !== <span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">this</span>.error = error;
    }
    <span class="hljs-keyword">if</span> (params !== <span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-built_in">Array</span>.isArray(params)) {
      <span class="hljs-keyword">this</span>.params.length = params.length;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = params.length; i--; )
        <span class="hljs-keyword">this</span>.params[i] = params[i];
    }
  };
 
  Call.prototype.setParams = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.params.length = <span class="hljs-built_in">arguments</span>.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-built_in">arguments</span>.length; i--; )
      <span class="hljs-keyword">this</span>.params[i] = <span class="hljs-built_in">arguments</span>[i];
  }

  <span class="hljs-comment">/** Begins a subcall with the given *block*.
   *
   *  @param  block The block ({begin.Block}, required)
   *  @return The subcall ({begin.Call}, non-null)
   *  @since  1.0
   */</span>
  Call.prototype.beginSubcall = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(block)</span> {</span>
    <span class="hljs-keyword">var</span> subcontext = extend({}, <span class="hljs-keyword">this</span>.context);
    <span class="hljs-keyword">var</span> subcall = <span class="hljs-keyword">new</span> Call(block || <span class="hljs-keyword">this</span>.block, subcontext);
    subcall.set(<span class="hljs-keyword">this</span>.error, <span class="hljs-keyword">this</span>.params);
    (<span class="hljs-keyword">this</span>.subcalls || (<span class="hljs-keyword">this</span>.subcalls = [])).push(subcall);
    subcall.index = <span class="hljs-keyword">this</span>.subcalls.length - <span class="hljs-number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>subcall.supercall = this;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.subcalls.length == <span class="hljs-number">1</span>) {
hook &amp;&amp; hook.emit(<span class="hljs-string">'onOpenSubcalls'</span>, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">this</span>.subcallErrors = [];
      <span class="hljs-keyword">this</span>.subcallParams = [];
    }
hook &amp;&amp; hook.emit(<span class="hljs-string">'onBeginSubcall'</span>, <span class="hljs-keyword">this</span>, subcall);
    <span class="hljs-keyword">return</span> subcall;
  };

  Call.prototype.endSubcall = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(subcall)</span> {</span>
    <span class="hljs-keyword">if</span> (!(subcall <span class="hljs-keyword">instanceof</span> Call))
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Subcall required (subcall="</span> + subcall + <span class="hljs-string">")"</span>);
    subcall.commit();
    <span class="hljs-keyword">this</span>.subcallErrors[subcall.index] = subcall.error;
    <span class="hljs-keyword">this</span>.subcallParams[subcall.index] = subcall.params[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">this</span>.subcalls[subcall.index] = <span class="hljs-literal">null</span>;
hook &amp;&amp; hook.emit(<span class="hljs-string">'onEndSubcall'</span>, <span class="hljs-keyword">this</span>, subcall);
  };
  
  <span class="hljs-comment">/** Commits the call specifically for subcalls after all subcalls are
   *  completed. It aggregates errors from all subcalls and takes the first
   *  parameter from each.
   *  
   *  @return this
   *  @since  1.0
   */</span>
  Call.prototype.commit = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.subcalls == <span class="hljs-literal">null</span>)
      <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> agg = <span class="hljs-keyword">this</span>.subcallsError;
    <span class="hljs-keyword">delete</span>(<span class="hljs-keyword">this</span>.subcallsError);</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>console.log(“Call.commit() before”, this);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, ic = <span class="hljs-keyword">this</span>.subcallErrors.length; i &lt; ic; i++) {
      <span class="hljs-keyword">var</span> error = <span class="hljs-keyword">this</span>.subcallErrors[i];
      <span class="hljs-keyword">if</span> (error == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">continue</span>;
      <span class="hljs-keyword">if</span> (agg == <span class="hljs-literal">null</span>) {
        agg = error;
      } <span class="hljs-keyword">else</span> {
        agg.message += <span class="hljs-string">'; '</span> + (error.message || error);
        (agg.errors || (agg.errors = [])).push(error);
      }
    }
    <span class="hljs-keyword">this</span>.error = agg;
    <span class="hljs-keyword">delete</span>(<span class="hljs-keyword">this</span>.subcallErrors);
    <span class="hljs-keyword">this</span>.params = <span class="hljs-keyword">this</span>.subcallParams;
    <span class="hljs-keyword">delete</span>(<span class="hljs-keyword">this</span>.subcallParams);
    <span class="hljs-keyword">delete</span>(<span class="hljs-keyword">this</span>.subcalls);
hook &amp;&amp; hook.emit(<span class="hljs-string">'onCloseSubcalls'</span>, <span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  
  
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Class</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.init.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  }
  
  Class.extend = extendClass;
 
  Class.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.constructor.name + <span class="hljs-string">'()'</span>;
  };
  
  Class.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  };
  
  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                                Statements                                | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-comment">/** The Stmt class is an abstract base class for all begin statements.
   *
   *  @MARK: - Stmt
   */</span>
  <span class="hljs-keyword">var</span> Stmt = begin.Stmt = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Stmt</span><span class="hljs-params">(owner)</span> {</span>
    <span class="hljs-keyword">this</span>.owner = owner;
hook &amp;&amp; hook.emit(<span class="hljs-string">'onCreateStmt'</span>, <span class="hljs-keyword">this</span>);
  };
  Stmt.kind = ArgKind;
  
  Stmt.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(owner)</span> {</span>
    <span class="hljs-keyword">this</span>.owner = owner;
  };
  
  Stmt.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.constructor.name + <span class="hljs-string">'()'</span>;
  };

  <span class="hljs-comment">/** Runs a statement with the given array of *args* where the first item is an
   *  error or undefined or null and the remaining items are parameters. The
   *  statement is run within a *context* of properties used for each field.
   *  
   *  The *callback(args)* is called upon completion of the statement, called
   *  with a single required argument, an array or arguments object, where the
   *  first item is an optional error.
   *  
   *  @param  args The statement input arguments ({array}, required)
   *  @param  context The context ({object}, required)
   *  @param  callback A completion callback ({function(args)}, optional)
   *  @since  1.0
   *  @MARK:  -run()
   */</span>
  Stmt.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span><span class="hljs-params">(call, callback)</span> {</span>
    callback(args);
  };
  
  <span class="hljs-comment">/** Invokes the *func* for the given *call* context.
   *
   *  @param  call The call ({begin.Call}, required)
   *  @param  func The function ({function(..)} or other, optional)
   *  @param  callback The callback ({function()}, required)
   *  @since  1.0
   */</span>
  Stmt.prototype.invoke = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(call, func, callback)</span> {</span>
    <span class="hljs-keyword">if</span> (!(call <span class="hljs-keyword">instanceof</span> Call))
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Call must be a Call: "</span> + call);
    <span class="hljs-keyword">var</span> context = call.context;
 
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(callback) != <span class="hljs-string">'function'</span>)
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Callback must be a function"</span>);
    <span class="hljs-keyword">if</span> (func === STACK_MARKER)
      <span class="hljs-keyword">return</span> call.error = <span class="hljs-literal">null</span>, callback();
    <span class="hljs-keyword">if</span> (isThenable(func)) {
      <span class="hljs-keyword">return</span> func.then(
        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(v)</span> {</span> call.setParams(v); callback() },
        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span> {</span> call.set(e); callback(); }
      );
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(func) !== <span class="hljs-string">'function'</span>) {
      <span class="hljs-keyword">return</span> call.setParams(func), callback();
    }
    
    <span class="hljs-keyword">var</span> sync = <span class="hljs-literal">true</span>, replied = <span class="hljs-literal">false</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replier</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">if</span> (replied) {
hook &amp;&amp; hook.emit(<span class="hljs-string">'onEndInvokeDup'</span>, call, call.stmt, func, <span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">return</span>;
      }
hook &amp;&amp; hook.emit(<span class="hljs-string">'onEndInvoke'</span>, call, call.stmt, func, replier, <span class="hljs-built_in">arguments</span>);
      call.stmt = call.replier = call.func = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> replier)
        context[key] = replier[key];
      call.set(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
      <span class="hljs-keyword">if</span> (sync)
        begin.setImmediate(callback);
      <span class="hljs-keyword">else</span>
        callback();
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> context)
      replier[key] = context[key];
    replier.call = call;
    <span class="hljs-keyword">try</span> {
      call.stmt = <span class="hljs-keyword">this</span>, call.replier = replier, call.func = func;
hook &amp;&amp; hook.emit(<span class="hljs-string">'onBeginInvoke'</span>, call, <span class="hljs-keyword">this</span>, func, replier);
      <span class="hljs-keyword">var</span> result = func.apply(replier, call.params);
      <span class="hljs-keyword">if</span> (result !== <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">if</span> (isThenable(result)) {
          result.then(
            <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> {</span> replier(<span class="hljs-literal">null</span>, value) },
            <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> {</span> replier(error, <span class="hljs-literal">null</span>) }
          );
        } <span class="hljs-keyword">else</span> {
          replier(<span class="hljs-literal">null</span>, result);
        }
      }
    } <span class="hljs-keyword">catch</span> (error) {
      replier(error, <span class="hljs-literal">null</span>);
    } <span class="hljs-keyword">finally</span> {
      sync = <span class="hljs-literal">false</span>;
    }
  };
 
  Stmt.extend = extendClass;
 
  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                              begin()..end()                              | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-keyword">var</span> Block = begin.Block = Stmt.extend(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Block</span><span class="hljs-params">(owner)</span> {</span>
    Stmt.call(<span class="hljs-keyword">this</span>, owner);
    <span class="hljs-keyword">this</span>.stmts = [];
  });
  Block.kind = ArgKind | BrkKind;

  Block.prototype.begin = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> stmt = <span class="hljs-keyword">new</span> Block(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.stmts.push(stmt);
    <span class="hljs-keyword">return</span> stmt;
  };

  Block.prototype.end = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span> {</span>
    <span class="hljs-keyword">var</span> owner = <span class="hljs-keyword">this</span>.owner;
    <span class="hljs-keyword">if</span> (owner &amp;&amp; !(owner <span class="hljs-keyword">instanceof</span> Block))
      owner = owner.owner;
    <span class="hljs-keyword">return</span> owner;
  };

  Block.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(call, callback)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>hook &amp;&amp; hook.emit(‘onBeginRun’, call, this);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stmts.length == <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>hook &amp;&amp; hook.emit(‘onEndRun’, call, this);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> callback();
    }
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>, count = <span class="hljs-keyword">this</span>.stmts.length;
    (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Block_next</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">var</span> kind = !call.error ? ArgKind
               : call.error == <span class="hljs-string">'break'</span> ? BrkKind
               : call.error == <span class="hljs-string">'return'</span> ? RetKind
               : ErrKind;
      <span class="hljs-keyword">var</span> stmt, stmtKind;</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>console.log(“-Block.run(): “ + index + “/“ + count + “: start kind=” + kind);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">while</span> (index &lt; count) {
        stmt = self.stmts[++index], stmtKind = stmt &amp;&amp; stmt.class.kind;</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>console.log(“-Block.run(): “ + index + “/“ + count + “: stmt=” + stmt + “, kind=” + stmtKind + “, use?=” + !!(stmtKind &amp; kind));</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (stmtKind &amp; kind) {</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>console.log(“-Block.run(): “ + index + “/“ + count + “: break”);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">break</span>;
        }
      }
      <span class="hljs-keyword">if</span> (stmt) {</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>console.log(“-Block.run(): “ + index + “/“ + count + “: run stmt=” + stmt);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        stmt.run(call, Block_next);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (call.error == <span class="hljs-string">'break'</span>)
          call.error = <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>hook &amp;&amp; hook.emit(‘onEndRun’, call, this);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        callback();
      }
    })();
  };

  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                              begin()..end()                              | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-keyword">var</span> Root = Block.Root = Block.extend(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RootBlock</span><span class="hljs-params">(owner, context, options)</span> {</span>
    Block.call(<span class="hljs-keyword">this</span>, owner);
    <span class="hljs-keyword">this</span>.context = context;
    <span class="hljs-keyword">this</span>.options = options || {};
  });
  
  begin.promise = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(context, options)</span> {</span>
    options || (options = {});
    options.promise = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Root(<span class="hljs-literal">null</span>, context, options);
  };
  begin.handler = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(context, options)</span> {</span>
    options || (options = {});
    options.handler = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Root(<span class="hljs-literal">null</span>, context, options);
  };
  begin.callback = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(context, options)</span> {</span>
    options || (options = {});
    options.callback = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Root(<span class="hljs-literal">null</span>, context, options);
  };

  Root.prototype.end = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">end</span><span class="hljs-params">(callback)</span> {</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.handler) {
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> call = <span class="hljs-keyword">new</span> Call(self);
        call.set(<span class="hljs-literal">null</span>, <span class="hljs-built_in">arguments</span>);
        call.run(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
          <span class="hljs-keyword">if</span> (callback) {
            callback.apply(<span class="hljs-literal">null</span>, [call.error].concat(call.params));
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (call.error) {
            <span class="hljs-keyword">throw</span> call.error;</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>console.log(“begin produced an error with no callback: “ + call.error + “\n” + call.error.stack);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          }
        });
      };
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.callback) {
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> call = <span class="hljs-keyword">new</span> Call(self);
        call.set(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
        call.run(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
          <span class="hljs-keyword">if</span> (callback) {
            callback.apply(<span class="hljs-literal">null</span>, [call.error].concat(call.params));
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (call.error) {
            <span class="hljs-keyword">throw</span> call.error;</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>console.log(“begin produced an error with no callback: “ + call.error + “\n” + call.error.stack);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          }
        });
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> call = <span class="hljs-keyword">new</span> Call(self);
      <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> Promise();
      call.run(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>console.log(“Done with call=”, call);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (call.error)
          promise._reject(call.error);
        <span class="hljs-keyword">else</span>
          promise._fulfill(call.params[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">if</span> (callback)
          callback.apply(<span class="hljs-literal">null</span>, [call.error].concat(call.params));</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <pre><code>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (call.error)
      <span class="hljs-comment">// throw call.error;</span>
      <span class="hljs-comment">// console.log("begin produced an error with no callback: " + call.error + "\n" + call.error.stack);</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>      });
      <span class="hljs-keyword">return</span> promise;
    }
  };

  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                                 then(fn)                                 | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-comment">/** The Then class defines a stmt for a single asynchronous
   *  function.
   *  
   *  @MARK: - Then
   */</span>
  <span class="hljs-keyword">var</span> Then = begin.Then = Stmt.extend(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Then</span><span class="hljs-params">(owner, func)</span> {</span>
    Stmt.call(<span class="hljs-keyword">this</span>, owner);
    <span class="hljs-keyword">this</span>.func = func;
  });
  
  Then.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(call, callback)</span> {</span> <span class="hljs-comment">// MARK: -run()</span>
    <span class="hljs-keyword">this</span>.invoke(call, <span class="hljs-keyword">this</span>.func, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      callback();
    });
  };
  
  Block.prototype.then = passify(syncify(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(func)</span> {</span> <span class="hljs-comment">// MARK: -block.then()</span>
    <span class="hljs-keyword">if</span> (func) {
      <span class="hljs-keyword">var</span> stmt = <span class="hljs-keyword">new</span> Then(<span class="hljs-keyword">this</span>, func);
      <span class="hljs-keyword">this</span>.stmts.push(stmt);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }));
  
  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                      if(fn).elseif(fn).else().end()                      | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-keyword">var</span> If = begin.If = Stmt.extend(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">If</span><span class="hljs-params">(owner, cond, negate)</span> {</span>
    Stmt.call(<span class="hljs-keyword">this</span>, owner);
    <span class="hljs-keyword">this</span>.negate = !!negate;
    <span class="hljs-keyword">this</span>.conds = [cond];
    <span class="hljs-keyword">this</span>.blocks = [<span class="hljs-keyword">new</span> begin.Block(<span class="hljs-keyword">this</span>)];
  });
  
  Block.prototype.if = syncify(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cond)</span> {</span> <span class="hljs-comment">// MARK: -block.if()</span>
    <span class="hljs-keyword">var</span> stmt = <span class="hljs-keyword">new</span> If(<span class="hljs-keyword">this</span>, cond, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">this</span>.stmts.push(stmt);
    <span class="hljs-keyword">return</span> stmt.blocks[<span class="hljs-number">0</span>];
  });
  Block.prototype.unless = syncify(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cond)</span> {</span> <span class="hljs-comment">// MARK: -block.unless()</span>
    <span class="hljs-keyword">var</span> stmt = <span class="hljs-keyword">new</span> If(<span class="hljs-keyword">this</span>, cond, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">this</span>.stmts.push(stmt);
    <span class="hljs-keyword">return</span> stmt.blocks[<span class="hljs-number">0</span>];
  });
  Block.prototype.elseif = syncify(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cond)</span> {</span> <span class="hljs-comment">// MARK: -block.elseif()</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.owner.elseif)
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unexpected .elseif()"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.owner.elseif(cond);
  }),
  Block.prototype.else = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span> <span class="hljs-comment">// MARK: -block.else()</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.owner.else)
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unexpected .else()"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.owner.else();
  };
 
  If.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(call, callback)</span> {</span> <span class="hljs-comment">// MARK: -run()</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>hook &amp;&amp; hook.emit(‘onBeginRun’, call, this);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> condArgs = call.params;
    <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>, count = <span class="hljs-keyword">this</span>.blocks.length;
    (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">If_next</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">if</span> (index &lt; count) {
        <span class="hljs-keyword">var</span> cond = self.conds[index],
            block = self.blocks[index];
        index++;
        call.set(<span class="hljs-literal">undefined</span>, condArgs);
        self.invoke(call, cond, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
          <span class="hljs-keyword">var</span> error = call.error, result = call.params[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">if</span> (call.error) {</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>hook &amp;&amp; hook.emit(‘onEndRun’, call, this);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> callback();
          }
          <span class="hljs-keyword">if</span> (!!result == !self.negate) { <span class="hljs-comment">/* TRUE */</span>
            block.run(call, callback);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt; count) { <span class="hljs-comment">/* FALSE, elseif */</span>
            If_next();
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.elseBlock) { <span class="hljs-comment">/* FALSE, else */</span>
            self.elseBlock.run(call, callback);
          } <span class="hljs-keyword">else</span> { <span class="hljs-comment">/* FALSE, no-else */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>hook &amp;&amp; hook.emit(‘onEndRun’, call, this);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            callback();
          }
        });
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>hook &amp;&amp; hook.emit(‘onEndRun’, call, this);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        callback();
      }
    })();
  };
  If.prototype.elseif = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cond)</span> {</span> <span class="hljs-comment">// MARK: -elseif()</span>
    <span class="hljs-keyword">var</span> block = <span class="hljs-keyword">new</span> Block(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.conds.push(cond);
    <span class="hljs-keyword">this</span>.blocks.push(block);
    <span class="hljs-keyword">return</span> block;
  },
  If.prototype.else = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span> <span class="hljs-comment">// MARK: -else()</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.elseBlock = <span class="hljs-keyword">new</span> Block(<span class="hljs-keyword">this</span>);
  };
 
  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                      case(fn).when(fn).else().end()                      | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-keyword">var</span> Case = begin.Case = begin.Stmt.extend(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Case</span><span class="hljs-params">(owner, control)</span> {</span>
    begin.Stmt.call(<span class="hljs-keyword">this</span>, owner);
    <span class="hljs-keyword">this</span>.control = control;
    <span class="hljs-keyword">this</span>.conds = [];
    <span class="hljs-keyword">this</span>.blocks = [];
    <span class="hljs-keyword">this</span>.elseBlock = <span class="hljs-literal">null</span>;
  });

  begin.Block.prototype.case = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(control)</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length == <span class="hljs-number">0</span>)
      control = <span class="hljs-string">'STACK'</span>;
    <span class="hljs-keyword">var</span> stmt = <span class="hljs-keyword">new</span> Case(<span class="hljs-keyword">this</span>, control);
    <span class="hljs-keyword">this</span>.stmts.push(stmt);
    <span class="hljs-keyword">return</span> stmt;
  };

  begin.Block.prototype.when = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cond)</span> {</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.owner.when)
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unexpected .when()"</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span>)
      cond = slice.call(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.owner.when(cond);
  };

  Case.prototype.when = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cond)</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span>)
      cond = slice.call(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">var</span> block = <span class="hljs-keyword">new</span> begin.Block(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.conds.push(cond);
    <span class="hljs-keyword">this</span>.blocks.push(block);
    <span class="hljs-keyword">return</span> block;
  };

  Case.prototype.else = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.elseBlock = <span class="hljs-keyword">new</span> begin.Block(<span class="hljs-keyword">this</span>);
  };

  Case.prototype.match = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(lhs, rhs)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>console.log(“lhs=” + lhs + “, rhs=” + rhs + “, regexp=” + (typeof(lhs) == ‘string’ &amp;&amp; (rhs instanceof RegExp)));</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (lhs == rhs) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (lhs == <span class="hljs-literal">null</span> || rhs == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(rhs)) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, ic = rhs.length; i &lt; ic; i++) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.match(lhs, rhs[i]))
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(lhs) == <span class="hljs-string">'string'</span> &amp;&amp; (rhs <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>))
      <span class="hljs-keyword">return</span> lhs.match(rhs);
    <span class="hljs-keyword">if</span> (lhs.getTime &amp;&amp; rhs.getTime &amp;&amp; lhs.getTime() == rhs.getTime())
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  };

  Case.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(call, callback)</span> {</span> <span class="hljs-comment">// MARK: -run()</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> control;
    <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>, count = <span class="hljs-keyword">this</span>.blocks.length;
 
    <span class="hljs-comment">/* Invoke the control value of the case, which we'll use to match */</span>
    self.invoke(call, <span class="hljs-keyword">this</span>.control, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">if</span> (call.error)
        <span class="hljs-keyword">return</span> callback();
      control = call.params[<span class="hljs-number">0</span>];
      Case_next();
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Case_next</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">if</span> (index &lt; count) {
          <span class="hljs-keyword">var</span> cond = self.conds[index], block = self.blocks[index];
          index++;
          call.params.splice(<span class="hljs-number">0</span>, call.params.length, control);
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(cond) == <span class="hljs-string">'function'</span>) {
            self.invoke(call, cond, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
              <span class="hljs-keyword">if</span> (call.error)
                <span class="hljs-keyword">return</span> callback();
              <span class="hljs-keyword">if</span> (!!call.params[<span class="hljs-number">0</span>]) {
                block.run(call, callback);
              } <span class="hljs-keyword">else</span> {
                Case_next();
              }
            });
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (self.match(control, cond)) {
              block.run(call, callback);
            } <span class="hljs-keyword">else</span> {
              Case_next();
            }
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.elseBlock) {
          self.elseBlock.run(call, callback);
        } <span class="hljs-keyword">else</span> {
          callback();
        }
      }
    });
  };

  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                             while(fn)..end()                             | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-keyword">var</span> While = begin.While = Stmt.extend(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">While</span><span class="hljs-params">(owner, cond, opts)</span> {</span> <span class="hljs-comment">// MARK: -init()</span>
    Stmt.call(<span class="hljs-keyword">this</span>, owner);
    <span class="hljs-keyword">this</span>.opts = opts || {};
    <span class="hljs-keyword">this</span>.cond = cond;
    <span class="hljs-keyword">this</span>.block = <span class="hljs-keyword">new</span> Block(<span class="hljs-keyword">this</span>);
  });
  While.kind = ArgKind | BrkKind;

  Block.prototype.while = syncify(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(opts, cond)</span> {</span> <span class="hljs-comment">// MARK: -block.while()</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length == <span class="hljs-number">1</span>) cond = opts, opts = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> stmt = <span class="hljs-keyword">new</span> While(<span class="hljs-keyword">this</span>, cond, opts);
    <span class="hljs-keyword">this</span>.stmts.push(stmt);
    <span class="hljs-keyword">return</span> stmt.block;
  });
  Block.prototype.until = syncify(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(opts, cond)</span> {</span> <span class="hljs-comment">// MARK: -block.util()</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length == <span class="hljs-number">1</span>) cond = opts, opts = <span class="hljs-literal">null</span>;
    opts || (opts = {});
    opts.negate = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.while(cond, opts);
  });

  While.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(owner, cond, opts)</span> {</span> <span class="hljs-comment">// MARK: -init()</span>
    Stmt.call(<span class="hljs-keyword">this</span>, owner);
    <span class="hljs-keyword">this</span>.opts = opts || {};
    <span class="hljs-keyword">this</span>.cond = cond;
    <span class="hljs-keyword">this</span>.block = <span class="hljs-keyword">new</span> Block(<span class="hljs-keyword">this</span>);
  };
  While.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(call, callback)</span> {</span> <span class="hljs-comment">// MARK: -run()</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> cond = <span class="hljs-keyword">this</span>.cond,
        condArgs = call.params.slice(),
        negate = !!<span class="hljs-keyword">this</span>.opts.negate;
    <span class="hljs-keyword">var</span> pauseTime = <span class="hljs-keyword">this</span>.opts.interval || <span class="hljs-number">0</span>;
    (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">While_next</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">var</span> nextTime = <span class="hljs-built_in">Date</span>.now() + pauseTime;
      self.invoke(call, cond, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> truth = call.params[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">if</span> (call.error) {
          call.set(<span class="hljs-literal">undefined</span>, condArgs);
          <span class="hljs-keyword">return</span> callback();
        }
        <span class="hljs-keyword">if</span> (!!truth == !negate) {
          self.block.run(call, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            <span class="hljs-keyword">if</span> (call.error) {
              call.set(<span class="hljs-literal">undefined</span>, condArgs);
              <span class="hljs-keyword">return</span> callback()
            }
            <span class="hljs-keyword">var</span> nextInterval = nextTime - <span class="hljs-built_in">Date</span>.now();
            <span class="hljs-keyword">if</span> (nextInterval &gt; <span class="hljs-number">4</span>)
              setTimeout(While_next, nextInterval);
            <span class="hljs-keyword">else</span>
              While_next();
          });
        } <span class="hljs-keyword">else</span> { <span class="hljs-comment">/* FALSE */</span>
          call.set(<span class="hljs-literal">undefined</span>, condArgs);
          callback();
        }
      });
    })();
  };
  While.prototype.elseif = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cond)</span> {</span> <span class="hljs-comment">// MARK: -elseif()</span>
    <span class="hljs-keyword">var</span> block = <span class="hljs-keyword">new</span> Block(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.conds.push(cond);
    <span class="hljs-keyword">this</span>.blocks.push(block);
    <span class="hljs-keyword">return</span> block;
  };
  While.prototype.else = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span> <span class="hljs-comment">// MARK: -else()</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.elseBlock = <span class="hljs-keyword">new</span> Block(<span class="hljs-keyword">this</span>);
  };
  

  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                             each(fn)..end()                              | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-keyword">var</span> Each = begin.Each = Stmt.extend(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Each</span><span class="hljs-params">(owner, opts, list)</span> {</span> <span class="hljs-comment">// MARK: -init()</span>
    Stmt.call(<span class="hljs-keyword">this</span>, owner);
    <span class="hljs-keyword">this</span>.opts = opts || {};
    <span class="hljs-keyword">this</span>.list = list;
    <span class="hljs-keyword">this</span>.block = <span class="hljs-keyword">new</span> Block(<span class="hljs-keyword">this</span>);
  });
  Each.kind = ArgKind | BrkKind;

  Block.prototype.each = syncify(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(opts, list)</span> {</span> <span class="hljs-comment">// MARK: -block.each()</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length == <span class="hljs-number">1</span>) list = opts, opts = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> stmt = <span class="hljs-keyword">new</span> Each(<span class="hljs-keyword">this</span>, opts, list);
    <span class="hljs-keyword">this</span>.stmts.push(stmt);
    <span class="hljs-keyword">return</span> stmt.block;
  });

  Each.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(call, callback)</span> {</span> <span class="hljs-comment">// MARK: -run()</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, block = <span class="hljs-keyword">this</span>.block;
    <span class="hljs-keyword">var</span> workers = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.opts.workers) || <span class="hljs-literal">Infinity</span>;
    
    <span class="hljs-keyword">this</span>.items(call, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">if</span> (call.error)
        <span class="hljs-keyword">return</span> callback();
      
      <span class="hljs-keyword">var</span> items = self.coerce(call.params[<span class="hljs-number">0</span>]);
      <span class="hljs-keyword">var</span> values = items[<span class="hljs-number">0</span>], keys = items[<span class="hljs-number">1</span>];
      <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>, done = <span class="hljs-number">0</span>, count = values.length;
      <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) {
        call.setParams([]);
        <span class="hljs-keyword">return</span> callback();
      }
      <span class="hljs-keyword">var</span> current = <span class="hljs-number">0</span>, replies = <span class="hljs-built_in">Array</span>(count);

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Each_next</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> idx = index++, value = values[idx], key = keys[idx];
        <span class="hljs-keyword">var</span> subcall = call.beginSubcall(block);
        subcall.params.splice(<span class="hljs-number">0</span>, subcall.params.length, value, key);
        current++;
        block.run(subcall, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
          current--, done++;
          call.endSubcall(subcall);
          <span class="hljs-keyword">if</span> (index &lt; count) {
            <span class="hljs-keyword">while</span> (current &lt; workers &amp;&amp; index &lt; count) Each_next();
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == <span class="hljs-number">0</span>) {
            call.commit();
            call.params.splice(<span class="hljs-number">0</span>, call.params.length, call.params.slice());
            callback();
          }
        });
      }
      <span class="hljs-keyword">while</span> (current &lt; workers &amp;&amp; index &lt; count) Each_next();
    });
  };
  
  Each.prototype.items = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(call, callback)</span> {</span> <span class="hljs-comment">// MARK: -items()</span>
    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">this</span>.list)) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'function'</span>:
        <span class="hljs-keyword">this</span>.invoke(call, <span class="hljs-keyword">this</span>.list, callback);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">'undefined'</span>:
        <span class="hljs-keyword">return</span> callback();
      <span class="hljs-keyword">default</span>:
        call.params = [<span class="hljs-keyword">this</span>.list];
        <span class="hljs-keyword">return</span> callback();
    }
  };
  Each.prototype.coerce = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(items)</span> {</span> <span class="hljs-comment">// MARK: -coerce()</span>
    <span class="hljs-keyword">var</span> values = [], keys = [];
    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">typeof</span>(items)) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>:
        <span class="hljs-keyword">if</span> (items == <span class="hljs-literal">null</span>)
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(items)) {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, ic = items.length; i &lt; ic; i++)
            values.push(items[i]), keys.push(i);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> items)
            values.push(items[key]), keys.push(key);
        }
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">'number'</span>:
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; items; i++)
          keys.push(i), values.push(i);
        <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">return</span> [values, keys];
  };
  
  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                              split()..end()                              | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-comment">/** The Split class defines a block-type
   *  
   *  @MARK:  - Split
   */</span>
  <span class="hljs-keyword">var</span> Split = begin.Split = Stmt.extend(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Split</span><span class="hljs-params">(owner)</span> {</span>
    Stmt.call(<span class="hljs-keyword">this</span>, owner);
    <span class="hljs-keyword">this</span>.block = <span class="hljs-keyword">new</span> Block(<span class="hljs-keyword">this</span>);
  });
  
  Block.prototype.split = syncify(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span> <span class="hljs-comment">// MARK: -block.split()</span>
    <span class="hljs-keyword">var</span> stmt = <span class="hljs-keyword">new</span> Split(<span class="hljs-keyword">this</span>);
    stmt.owner = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.stmts.push(stmt);
    <span class="hljs-keyword">return</span> stmt.block;
  });

  Split.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(call, callback)</span> {</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, block = <span class="hljs-keyword">this</span>.block, stmts = block.stmts;
    <span class="hljs-keyword">var</span> inCount = stmts.length, outCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; inCount; i++) {
      (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(i)</span> {</span>
        <span class="hljs-keyword">var</span> stmt = stmts[i];
        <span class="hljs-keyword">var</span> subcall = call.beginSubcall(block);
        debugger;
        stmt.run(subcall, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
          call.endSubcall(subcall);
          <span class="hljs-keyword">if</span> (++outCount == inCount) {
            call.commit();
            callback();
          }
        });
      })(i);
    }
  };

  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                            stream(fn)..end()                             | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-keyword">var</span> Stream = begin.Stream = Stmt.extend(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Stream</span><span class="hljs-params">(owner, opts, stream)</span> {</span>
    Stmt.call(<span class="hljs-keyword">this</span>, owner);</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>console.log(“-Stream(): stream with opts=” + opts + “, stream=” + stream);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.opts = opts;
    <span class="hljs-keyword">this</span>.stream = stream;
    <span class="hljs-keyword">this</span>.block = <span class="hljs-keyword">new</span> Block(<span class="hljs-keyword">this</span>);
  });

  Block.prototype.stream = syncify(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(opts, stream)</span> {</span> <span class="hljs-comment">// MARK: -block.stream()</span>
    <span class="hljs-keyword">var</span> stmt;
    <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">arguments</span>.length) {
      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: stream = STACK_MARKER, opts = <span class="hljs-literal">null</span>; <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: stream = opts, opts = <span class="hljs-literal">null</span>; <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">var</span> stmt = <span class="hljs-keyword">new</span> Stream(<span class="hljs-keyword">this</span>, opts, stream);
    stmt.owner = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.stmts.push(stmt);
    <span class="hljs-keyword">return</span> stmt.block;
  });
  
  Stream.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(call, callback)</span> {</span> <span class="hljs-comment">// MARK: -run()</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, block = <span class="hljs-keyword">this</span>.block;
    <span class="hljs-keyword">var</span> stop = <span class="hljs-literal">false</span>, inCount = <span class="hljs-number">0</span>, outCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> oldArgs = call.params.slice();</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>console.log(“-Stream.run(): invoking call with this.stream=”, this.stream);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.invoke(call, <span class="hljs-keyword">this</span>.stream, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">if</span> (call.error)
        <span class="hljs-keyword">return</span> callback();
      <span class="hljs-keyword">var</span> stream = call.params[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">var</span> dataEvent  = self.opts &amp;&amp; self.opts.data  || <span class="hljs-string">'data'</span>,
          errorEvent = self.opts &amp;&amp; self.opts.error || <span class="hljs-string">'error'</span>,
          closeEvent = self.opts &amp;&amp; self.opts.close || <span class="hljs-string">'close'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>console.log(“-Stream.run(): called stream, call=”, call);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">if</span> (stream == <span class="hljs-literal">null</span>) {
        call.setParams([]);
        <span class="hljs-keyword">return</span> callback();
      }
      stream.on(dataEvent, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> {</span>
        <span class="hljs-keyword">var</span> subcall = call.beginSubcall(block);
        subcall.params = [data, inCount++, stream];
        block.run(subcall, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
          outCount++;</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>console.log(“-Stream.run(): +” + inCount + “/-“ + outCount + “ end subcall=”, subcall);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          call.endSubcall(subcall);</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>console.log(“-Stream.run(): iteration +” + inCount + “/-“ + outCount + “ call=” + call);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (stop &amp;&amp; outCount == inCount) {
            call.commit();
            call.params.splice(<span class="hljs-number">0</span>, call.params.length, call.params.slice());</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>console.log(“-Stream.run(): call=”, call);
console.log(“-Stream.run(): +” + inCount + “/-“ + outCount + “ done on data, call=”, call);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            callback();
          }
        });
      });
      stream.once(errorEvent, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>console.log(“-Stream.run(): +” + inCount + “/-“ + outCount + “ stopped=” + stop + “, error called: “ + err + “, call=”, call);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (stop) <span class="hljs-keyword">return</span>;
        stop = <span class="hljs-literal">true</span>;
        call.subcallsError = err || <span class="hljs-string">'error'</span>;
        <span class="hljs-keyword">if</span> (outCount == inCount) {
          call.commit();</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>console.log(“-Stream.run(): done on error, call=”, call);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          callback();
        }
      });
      stream.once(closeEvent, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>console.log(“-Stream.run(): +” + inCount + “/-“ + outCount + “ stopped=” + stop + “, close called”);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (stop) <span class="hljs-keyword">return</span>;
        stop = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (outCount == inCount) {
          call.commit();
          callback();
        }
      });
    });
    
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">done</span><span class="hljs-params">()</span> {</span>
      call.commit();
      call.params.splice(<span class="hljs-number">0</span>, call.params.length, call.params.slice());
      callback();
    }
  
  };

  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                                 wait(ms)                                 | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-comment">/** The Wait class defines a block-type
   *  
   *  @MARK:  - Wait
   */</span>
  <span class="hljs-keyword">var</span> Wait = begin.Wait = Stmt.extend(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Wait</span><span class="hljs-params">(owner, timeout)</span> {</span>
    Stmt.call(<span class="hljs-keyword">this</span>, owner);
    <span class="hljs-keyword">this</span>.timeout = timeout || <span class="hljs-number">0</span>;
  });

  Block.prototype.wait = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(timeout)</span> {</span> <span class="hljs-comment">// MARK: -block.split()</span>
    <span class="hljs-keyword">var</span> stmt = <span class="hljs-keyword">new</span> Wait(<span class="hljs-keyword">this</span>, timeout);
    stmt.owner = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.stmts.push(stmt);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  Wait.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(call, callback)</span> {</span>
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      callback();
    }, <span class="hljs-keyword">this</span>.timeout);
  };
    

  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                             retry(n)..end()                              | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-comment">/** The Retry class defines a block-type
   *  
   *  @MARK:  - Retry
   */</span>
  <span class="hljs-keyword">var</span> Retry = begin.Retry = Stmt.extend(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Retry</span><span class="hljs-params">(owner, count)</span> {</span>
    Stmt.call(<span class="hljs-keyword">this</span>, owner);
    <span class="hljs-keyword">this</span>.block = <span class="hljs-keyword">new</span> Block(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.count = count;
  });
  Retry.kind = ArgKind | BrkKind;
  
  Block.prototype.retry = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(count)</span> {</span> <span class="hljs-comment">// MARK: -block.split()</span>
    <span class="hljs-keyword">var</span> stmt = <span class="hljs-keyword">new</span> Retry(<span class="hljs-keyword">this</span>, count);
    stmt.owner = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.stmts.push(stmt);
    <span class="hljs-keyword">return</span> stmt.block;
  };
  
  Retry.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(call, callback)</span> {</span>
    <span class="hljs-keyword">var</span> block = <span class="hljs-keyword">this</span>.block, index = <span class="hljs-number">0</span>, count = <span class="hljs-keyword">this</span>.count;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">again</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">if</span> (index++ &gt;= <span class="hljs-keyword">this</span>.count)
        callback();
      block.run(call, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> {</span>
        <span class="hljs-keyword">if</span> (!err)
          <span class="hljs-keyword">return</span> callback &amp;&amp; callback();
      });
    }
    again();
  };

  <span class="hljs-comment">/* 
   * This each statement above could be rewritten as any one the following are
   * functionally equivalent. They all create an each statement which iterates
   * over an array.
   */</span>

  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                        catch(fn) | catch()..end()                        | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-keyword">var</span> Catch = begin.Catch = Stmt.extend(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Catch</span><span class="hljs-params">(owner, func)</span> {</span> <span class="hljs-comment">// MARK: -init()</span>
    Stmt.call(<span class="hljs-keyword">this</span>, owner);
    <span class="hljs-keyword">this</span>.func = func;
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.func)
      <span class="hljs-keyword">this</span>.block = <span class="hljs-keyword">new</span> Block(<span class="hljs-keyword">this</span>);
  });

  Catch.kind = ErrKind | BrkKind;
  
  Block.prototype.catch = passify(syncify(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(func)</span> {</span> <span class="hljs-comment">// MARK: -block.catch()</span>
    <span class="hljs-keyword">var</span> stmt = <span class="hljs-keyword">new</span> Catch(<span class="hljs-keyword">this</span>, func);
    <span class="hljs-keyword">this</span>.stmts.push(stmt);
    <span class="hljs-keyword">return</span> stmt.block || <span class="hljs-keyword">this</span>;
  }));

  Catch.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(call, callback)</span> {</span> <span class="hljs-comment">// MARK: -run()</span>
    call.params.splice(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, call.error), call.error = <span class="hljs-literal">null</span>;
    
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.func) {
      <span class="hljs-keyword">this</span>.invoke(call, <span class="hljs-keyword">this</span>.func, callback);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.block) {</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <pre><code> call.unshift(call.error), call.error = <span class="hljs-literal">null</span>;
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">this</span>.block.run(call, callback);
    }
  };
    
  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                      finally(fn) | finally()..end()                      | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-comment">/** The Stmt.Finally class defines a block-type
   *  
   *  @MARK:  - Finally
   */</span>
  <span class="hljs-keyword">var</span> Finally = begin.Finally = Stmt.extend(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Finally</span><span class="hljs-params">(owner, func)</span> {</span>
    Stmt.call(<span class="hljs-keyword">this</span>, owner);
    <span class="hljs-keyword">this</span>.func = func;
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.func)
      <span class="hljs-keyword">this</span>.block = <span class="hljs-keyword">new</span> Block(<span class="hljs-keyword">this</span>);
  });

  Finally.kind = AllKind | BrkKind;
  
  Block.prototype.finally = passify(syncify(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(func)</span> {</span>
    <span class="hljs-keyword">var</span> stmt = <span class="hljs-keyword">new</span> Finally(<span class="hljs-keyword">this</span>, func);
    <span class="hljs-keyword">this</span>.stmts.push(stmt);
    <span class="hljs-keyword">return</span> stmt.block || <span class="hljs-keyword">this</span>;
  }));

  Finally.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(call, callback)</span> {</span>
    call.params.unshift(call.error), call.error = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.func) {
      <span class="hljs-keyword">this</span>.invoke(call, <span class="hljs-keyword">this</span>.func, callback);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.block) {
      <span class="hljs-keyword">this</span>.block.run(call, callback);
    }
  };
    
  <span class="hljs-comment">/** The Get class defines a block-type
   *  
   *  @MARK:  - Get
   */</span>
  <span class="hljs-keyword">var</span> Get = begin.Get = Stmt.extend(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Get</span><span class="hljs-params">(owner, keys)</span> {</span>
    Stmt.call(<span class="hljs-keyword">this</span>, owner);
    <span class="hljs-keyword">this</span>.keys = keys;
  });

  Block.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> stmt = <span class="hljs-keyword">new</span> Get(<span class="hljs-keyword">this</span>, slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>));
    <span class="hljs-keyword">this</span>.stmts.push(stmt);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  Get.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(call, callback)</span> {</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, ic = <span class="hljs-keyword">this</span>.keys.length; i &lt; ic; i++) {
      <span class="hljs-keyword">var</span> value = call.context[<span class="hljs-keyword">this</span>.keys[i]];
      call.params.splice(i, <span class="hljs-number">0</span>, value);
    }
    callback();
  };

  <span class="hljs-comment">/** The Set class defines a block-type
   *  
   *  @MARK:  - Set
   */</span>
  <span class="hljs-keyword">var</span> Set = begin.Set = Stmt.extend(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Set</span><span class="hljs-params">(owner, keys)</span> {</span>
    Stmt.call(<span class="hljs-keyword">this</span>, owner);
    <span class="hljs-keyword">this</span>.keys = keys;
  });

  Block.prototype.set = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(key)</span> {</span>
    <span class="hljs-keyword">var</span> stmt = <span class="hljs-keyword">new</span> Set(<span class="hljs-keyword">this</span>, slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>));
    <span class="hljs-keyword">this</span>.stmts.push(stmt);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  Set.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(call, callback)</span> {</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, ic = <span class="hljs-keyword">this</span>.keys.length; i &lt; ic; i++) {
      call.context[<span class="hljs-keyword">this</span>.keys[i]] = call.params[i];
    }
    callback();
  };

  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                          Working with Promises                           | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-comment">/** Returns whether *value* is a promise.
   *
   *  @since  1.0
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isThenable</span><span class="hljs-params">(value)</span> {</span>
    <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">typeof</span>(value);
    <span class="hljs-keyword">return</span> value != <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-string">'object'</span> == type || <span class="hljs-string">'function'</span> == type) &amp;&amp; <span class="hljs-keyword">typeof</span>(value.then) == <span class="hljs-string">'function'</span>;
  }

  <span class="hljs-comment">/** The begin.Promise class provides a Promises/A+ implementation with a
   *  minimal memory and CPU footprint.
   *  
   *  @since  1.0
   *  @MARK:  - begin.Promise
   */</span>
  <span class="hljs-keyword">var</span> Promise = begin.Promise = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span><span class="hljs-params">(executor)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>this._state = 0;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (executor) {
      <span class="hljs-keyword">try</span> {
        executor(<span class="hljs-keyword">this</span>._fulfill.bind(<span class="hljs-keyword">this</span>), <span class="hljs-keyword">this</span>._reject.bind(<span class="hljs-keyword">this</span>));
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-keyword">this</span>._reject(error);
      }
    }
  };
  Promise.PENDING = <span class="hljs-number">0</span>;
  Promise.REJECTED = <span class="hljs-number">1</span>;
  Promise.FULFILLED = <span class="hljs-number">2</span>;
  Promise.RESOLVED = Promise.REJECTED &amp; Promise.FULFILLED;

  Promise.prototype._call = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(next)</span> {</span>
    <span class="hljs-keyword">var</span> key, handler, param, promise = next._promise;
    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>._state) {
      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: key = <span class="hljs-string">'_reject'</span>, param = <span class="hljs-keyword">this</span>._error; <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: key = <span class="hljs-string">'_fulfill'</span>, param = <span class="hljs-keyword">this</span>._value; <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">default</span>: <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Must be resolved"</span>);
    }
    <span class="hljs-keyword">if</span> (handler = next[key]) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (next._called) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Next already called"</span>);
        next._called = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">var</span> value = handler(param);
        <span class="hljs-keyword">if</span> (value &amp;&amp; <span class="hljs-keyword">typeof</span>(value.then) == <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">try</span> {
            value.then(promise._fulfill.bind(promise), promise._reject.bind(promise));
          } <span class="hljs-keyword">catch</span> (error) {
            promise._reject(error);
          }
        } <span class="hljs-keyword">else</span> {
          promise._fulfill(value);
        }
      } <span class="hljs-keyword">catch</span> (error) {
        promise._reject(error);
      }
    } <span class="hljs-keyword">else</span> {
      promise[key](<span class="hljs-keyword">this</span>._value);
    }
  };

  Promise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(onFulfilled, onRejected)</span> {</span>
    <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> Promise();
    <span class="hljs-keyword">var</span> next = {
      _fulfill: <span class="hljs-keyword">typeof</span>(onFulfilled) === <span class="hljs-string">'function'</span> ? onFulfilled : <span class="hljs-literal">null</span>,
      _reject:  <span class="hljs-keyword">typeof</span>(onRejected) === <span class="hljs-string">'function'</span> ? onRejected : <span class="hljs-literal">null</span>,
      _promise: promise
    };
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._state) {
      <span class="hljs-keyword">this</span>._nexts ? <span class="hljs-keyword">this</span>._nexts.push(next) : <span class="hljs-keyword">this</span>._nexts = [next];
    } <span class="hljs-keyword">else</span> {
      begin.setImmediate(<span class="hljs-keyword">this</span>._call.bind(<span class="hljs-keyword">this</span>, next));
    }
    <span class="hljs-keyword">return</span> promise;
  };

  Promise.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(onRejected)</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">null</span>, onRejected);
  };

  Promise.prototype._fulfill = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._state) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">this</span>._state = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">this</span>._value = value;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._flush();
  };

  Promise.prototype._reject = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._state) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">this</span>._state = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">this</span>._error = error;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._flush();
  };

  Promise.prototype._flush = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._nexts) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, ic = <span class="hljs-keyword">this</span>._nexts.length; i &lt; ic; i++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>console.log(“_flush: deferring _call with next: “, this._nexts[i]);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        begin.setImmediate(<span class="hljs-keyword">this</span>._call.bind(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>._nexts[i]));
      }
      <span class="hljs-keyword">delete</span>(<span class="hljs-keyword">this</span>._nexts);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
 
  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                                  Hooks                                   | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-keyword">var</span> hook = <span class="hljs-literal">null</span>;
 
  <span class="hljs-keyword">var</span> Hook = begin.Hook = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Hook</span><span class="hljs-params">()</span> {</span> <span class="hljs-keyword">this</span>.init.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>) };
  Hook.extend = extendClass;
  Hook.init = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  };
  Hook.prototype.install = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (!hook)
      <span class="hljs-keyword">return</span> Hook.instrument(), hook = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> prev = hook;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> cur; cur = prev._next; prev = cur);
    <span class="hljs-keyword">this</span>._prev = prev;
    <span class="hljs-keyword">return</span> prev._next = <span class="hljs-keyword">this</span>;
  };
  Hook.prototype.uninstall = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> prev = <span class="hljs-keyword">this</span>._prev,
        next = <span class="hljs-keyword">this</span>._next;
    <span class="hljs-keyword">if</span> (prev)
      <span class="hljs-keyword">this</span>._prev = <span class="hljs-literal">null</span>, prev._next = next;
    <span class="hljs-keyword">if</span> (next)
      <span class="hljs-keyword">this</span>._next = <span class="hljs-literal">null</span>, next._prev = prev || hook = next || Hook.uninstrument();
  };
  Hook.instrument = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> begin) {
      <span class="hljs-keyword">var</span> value = begin[key], run;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(value) != <span class="hljs-string">'function'</span> || key &lt; <span class="hljs-string">'A'</span> || <span class="hljs-string">'Z'</span> &lt; key)
        <span class="hljs-keyword">continue</span>;
      <span class="hljs-keyword">var</span> proto = value.prototype;
      <span class="hljs-keyword">if</span> (run = proto.run) {
        proto._run = run;
        proto.run = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(call, callback)</span> {</span>
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
          hook.emit(<span class="hljs-string">'onBeginRun'</span>, call, <span class="hljs-keyword">this</span>);
          <span class="hljs-keyword">this</span>._run(call, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            hook.emit(<span class="hljs-string">'onEndRun'</span>, call, self);
            callback();
          });
        };
      }
    }
  };
  Hook.uninstrument = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> begin) {
      <span class="hljs-keyword">var</span> value = begin[key], run;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(value) != <span class="hljs-string">'function'</span> || key &lt; <span class="hljs-string">'A'</span> || <span class="hljs-string">'Z'</span> &lt; key)
        <span class="hljs-keyword">continue</span>;
      <span class="hljs-keyword">var</span> proto = value.prototype;
      proto.run = proto._run;
      <span class="hljs-keyword">delete</span>(proto._run);
    }
  };
  Hook.prototype.emit = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event, args)</span> {</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(args))
      args = slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[event]) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">this</span>[event].apply(<span class="hljs-keyword">this</span>, args);
      } <span class="hljs-keyword">catch</span> (error) {
        console.log(<span class="hljs-string">"begin: IMPL Hook, "</span> + <span class="hljs-keyword">this</span> + <span class="hljs-string">", while handling event, '"</span> + event + <span class="hljs-string">"', produced error: "</span> + error, error.stack);
      }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._next)
      <span class="hljs-keyword">this</span>._next.emit(event, args);
  };
 
  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                            Utility Functions                             | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span><span class="hljs-params">(item, props)</span> {</span>
    item || (item = {});
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> props) {
      <span class="hljs-keyword">var</span> value = props[key];
      <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>)
        item[key] = props[key];
      <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">delete</span>(item[key])
    }
    <span class="hljs-keyword">return</span> item;
  }
 
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extendClass</span><span class="hljs-params">(subclass)</span> {</span>
    subclass.superclass = <span class="hljs-keyword">this</span>;
    subclass.prototype = <span class="hljs-built_in">Object</span>.create(<span class="hljs-keyword">this</span>.prototype, {
      constructor: { value:subclass, enumerable:<span class="hljs-literal">false</span> },
      <span class="hljs-keyword">class</span>: { value:subclass, enumerable:<span class="hljs-literal">false</span> },
    });
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) {
      subclass[key] = <span class="hljs-keyword">this</span>[key];
    }
    <span class="hljs-keyword">return</span> subclass;
  }
 
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">syncify</span><span class="hljs-params">(func)</span> {</span>
    func.sync = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span> <span class="hljs-keyword">return</span> func.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>) || <span class="hljs-literal">null</span> };
    <span class="hljs-keyword">return</span> func;
  }
  
  <span class="hljs-comment">/** Passify is used when defining methods on Block, which allows handler
   *  functions to be transparent to the flow. Meaning, return values,
   *  exceptions throw or calls to this() are ignored and the call state is
   *  restored before continuing.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">passify</span><span class="hljs-params">(func)</span> {</span>
    func.pass = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">var</span> next = <span class="hljs-keyword">this</span>, args = <span class="hljs-built_in">arguments</span>, replied = <span class="hljs-literal">false</span>;
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replier</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">if</span> (replied) <span class="hljs-keyword">return</span>;
        replied = <span class="hljs-literal">true</span>;
        next.apply(next, args);
      }
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>)
        replier[key] = <span class="hljs-keyword">this</span>[key];
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">var</span> value = func.apply(replier, <span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">if</span> (value !== <span class="hljs-literal">undefined</span>)
          replier();
      } <span class="hljs-keyword">catch</span> (error) {
        replier();
      }
    };
    <span class="hljs-keyword">return</span> func;
  }
  
  <span class="hljs-comment">/*+-------------------------------------------------------------------------* 
   |                                 Exports                                  | 
   *--------------------------------------------------------------------------*/</span>

  <span class="hljs-comment">/* Export */</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(define) !== <span class="hljs-string">'undefined'</span> &amp;&amp; define.amd) {
    define(<span class="hljs-string">'begin'</span>, [], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span> <span class="hljs-keyword">return</span> begin });
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(module) !== <span class="hljs-string">'undefined'</span> &amp;&amp; module.exports) {
    module.exports = begin;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> prev = root.begin;
    root.begin = begin;
    root.begin.noConflict = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      root.begin = prev;
      <span class="hljs-keyword">return</span> begin;
    };
  }
  
})(<span class="hljs-keyword">this</span>);</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
